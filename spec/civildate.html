<!doctype html>
<meta charset="utf8">

<emu-clause id=sec-temporal-date>
  <h1>Temporal.Date Objects</h1>
  <p>A Temporal.Date object is an immutable Object that contains Number values corresponding to a particular year, month,
    and day.</p>

  <emu-clause id=sec-temporal-date-constructor>
    <h1>The Temporal.Date Constructor</h1>
    <p>The Temporal.Date constructor is the %Temporal.Date% intrinsic object. When called as a constructor, it creates and
      initializes a new Temporal.Date object.</p>
    <p>
      The Temporal.Date constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified Date behaviour must include a super call to the %Temporal.Date% constructor to create and initialize subclass instances with the necessary internal slots.</p>

    <emu-clause id=sec-temporal-date-constructor-alg>
      <h1>Temporal.Date ( _year_, _month_, _day_ )</h1>
      <p>When the Temporal.Date function is called, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _numberOfArgs_ be the number of arguments passed to this function call.
        1. If _numberOfArgs_ &lt; 3, then:
          1. Throw a *TypeError* exception.
        1. Let _y_ be ? TemporalToInteger(_year_).
        1. Let _m_ be ? TemporalToInteger(_month_).
        1. Let _d_ be ? TemporalToInteger(_day_).
        1. If ! ValidateDate(_y_, _m_, _d_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Return CreateDate(_y_, _m_, _d_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id=sec-properties-of-the-temporal-date-constructor>
    <h1>Properties of the Temporal.Date Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.Date constructor is the intrinsic object
      %FunctionPrototype%.</p>
    <p>The Temporal.Date constructor has the following properties:</p>

    <emu-clause id=sec-temporal-date-prototype>
      <h1>Temporal.Date.prototype</h1>
      <p>The initial value of Temporal.Date.prototype is %Temporal.Date.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.fromString( _isostring_ )</h1>
      <p>
        The `fromString` method takes one argument _isostring_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _validSyntax_ be *true* if _isostring_ conforms to the format `YYYY-MM-DD`, and *false* otherwise, where:
          * `YYYY` is either four decimal digits or an expanded year of `"+"` or `"-"` followed by six decimal digits;
          * `-` is the code unit 0x002D (HYPHEN-MINUS);
          * `MM` is two decimal digits;
          * `-` is the code unit 0x002D (HYPHEN-MINUS);
          * `DD` is two decimal digits.
        1. If _validSyntax_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _year_, _month_, and _day_ be the respective parts of _isostring_, interpreted as decimal numbers.
        1. If ! ValidateDate(_year_, _month_, _day_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Return CreateDate(_year_, _month_, _day_).
      </emu-alg>
    </emu-clause>

<!-- TODO
CivilDate.compare()?
-->
  </emu-clause>

  <emu-clause id=sec-properties-of-the-temporal-date-prototype-object>
    <h1>Properties of the Temporal.Date Prototype Object</h1>

    <p>The Temporal.Date prototype object</p>
    <ul>
      <li>is the intrinsic object %Temporal.Date.prototype%.
      <li>is itself an ordinary object.
      <li>is not a Temporal.Date instance and does not have a [[InitializedTemporalDate]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id=sec-temporal.date.prototype.constructor>
      <h1>Temporal.Date.prototype.constructor</h1>
      <p>The initial value of Temporal.Date.prototype.constructor is %Temporal.Date%.</p>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.year</h1>
      <p>
        Temporal.Date.prototype.year is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.month</h1>
      <p>
        Temporal.Date.prototype.month is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Month]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.day</h1>
      <p>
        Temporal.Date.prototype.day is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Day]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.dayOfWeek</h1>
      <p>
        Temporal.Date.prototype.dayOfWeek is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToDayOfWeek(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.dayOfYear</h1>
      <p>
        Temporal.Date.prototype.dayOfYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToDayOfYear(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.weekOfYear</h1>
      <p>
        Temporal.Date.prototype.weekOfYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToWeekOfYear(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.getYearMonth()</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return CreateYearMonth(_date_.[[Year]], _date_.[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.getMonthDay()</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return CreateMonthDay(_date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.plus( _duration_ )</h1>
      <p>
        The `plus` method takes one argument _duration_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _duration_ be ? ToDurationLike(_duration_).
        1. <mark>TODO: Throw if any time properties are present?</mark>
        1. If _duration_.[[Year]] is not *undefined*, then
          1. Let _y_ be _date_.[[Year]] + _duration_.[[Year]].
        1. Else
          1. Let _y_ be _date_.[[Year]].
        1. If _duration_.[[Month]] is not *undefined*, then
          1. Let _y_ be _date_.[[Month]] + _duration_.[[Month]].
        1. Else
          1. Let _y_ be _date_.[[Month]].
        1. If _duration_.[[Day]] is not *undefined*, then
          1. Let _y_ be _date_.[[Day]] + _duration_.[[Day]].
        1. Else
          1. Let _y_ be _date_.[[Day]].
        1. Regulate the _y_, _m_, and _d_ values using Gregorian pro-leptic calendar calculations.
        1. Return CreateDate(_y_, _m_, _d_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.minus( _duration_ )</h1>
      <p>
        The `plus` method takes one argument _duration_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _duration_ be ? ToDurationLike(_duration_).
        1. <mark>TODO: Throw if any time properties are present?</mark>
        1. If _duration_.[[Year]] is not *undefined*, then
          1. Let _y_ be _date_.[[Year]] - _duration_.[[Year]].
        1. Else
          1. Let _y_ be _date_.[[Year]].
        1. If _duration_.[[Month]] is not *undefined*, then
          1. Let _y_ be _date_.[[Month]] - _duration_.[[Month]].
        1. Else
          1. Let _y_ be _date_.[[Month]].
        1. If _duration_.[[Day]] is not *undefined*, then
          1. Let _y_ be _date_.[[Day]] - _duration_.[[Day]].
        1. Else
          1. Let _y_ be _date_.[[Day]].
        1. Regulate the _y_, _m_, and _d_ values using Gregorian pro-leptic calendar calculations.
        1. Return CreateDate(_y_, _m_, _d_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.with( _duration_ )</h1>
      <p>
        The `with` method takes one argument _duration_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _duration_ be ? ToDateDurationLike(_duration_).
        1. If _duration_.[[Year]] is not *undefined*, then
          1. Let _y_ be _duration_.[[Year]].
        1. Else
          1. Let _y_ be _date_.[[Year]].
        1. If _duration_.[[Month]] is not *undefined*, then
          1. Let _m_ be _duration_.[[Month]].
        1. Else
          1. Let _m_ be _date_.[[Month]].
        1. If _duration_.[[Day]] is not *undefined*, then
          1. Let _d_ be _duration_.[[Day]].
        1. Else
          1. Let _d_ be _date_.[[Day]].
        1. Regulate the _y_, _m_, and _d_ values using Gregorian pro-leptic calendar calculations.
        1. Return CreateDate(_y_, _m_, _d_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.difference( _otherDate_ )</h1>
      <p>
        The `difference` method takes one argument _otherDate_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _otherDate_ be ? ToDateLike(_otherDate_).
        1. If one of _otherDate_.[[Year]], _otherDate_.[[Month]], and _otherDate_.[[Day]] is *undefined*, then
          1. Throw a *TypeError* exception.
        1. <mark>TODO: Should this just take an actual Temporal.Date?</mark>
        1. If ! ValidateDate(_otherDate_.[[Year]], _otherDate_.[[Month]], _otherDate_.[[Day]]) is *false*, then
          1. Throw a *TypeError* exception.
        1. <mark>TODO: Throw if any time properties are present?</mark>
        1. Let _greater_ be _date_.
        1. Let _smaller_ be _otherDate_.
        1. <mark>TODO: Swap order if needed.</mark>
        1. Let _years_ be _greater_.[[Year]] - _smaller_.[[Year]].
        1. Let _months_ be _greater_.[[Month]] - _smaller_.[[Month]].
        1. Let _days_ be _greater_.[[Day]] - _smaller_.[[Day]].
        1. If _months_ &lt; 0, then
          1. Set _years_ to _years_ - 1.
          1. Set _months_ to _months_ + 12.
        1. If _days_ &lt; 0, then
          1. Set _months_ to _months_ - 1.
          1. Let _daysInMonth_ be DaysInMonth(_smaller_.[[Year]] + _years_, (_smaller_.[[Month]] + _months_) modulo 12)).
          1. Set _days_ to _days_ + _daysInMonth_.
        1. Return CreateDuration(_years_, _months_, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.withTime( _time_ )</h1>
      <p>
        The `withTime` method takes one argument _time_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _time_ be ? ToTimeLike(_time_).
        1. <mark>TODO: Should this take a Temporal.Time instead?</mark>
        1. If any of _time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _time_.[[Millisecond]], _time_.[[Microsecond]], or _time_.[[Nanosecond]] is *undefined*, then
          1. <mark>TODO: Merge into ToTimeLike?</mark>
          1. Throw a *TypeError* exception.
        1. Return CreateDateTime(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]],
          _time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]],
          _time_.[[Millisecond]], _time_.[[Microsecond]], _time_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.toString()</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _year_ be PadYear(_date_.[[Year]]).
        1. Let _month_ be _date_.[[Month]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _date_.[[Day]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), and _day_.
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.toJSON()</h1>
      <p><mark>TODO: Share with toString().</mark></p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _year_ be PadYear(_date_.[[Year]]).
        1. Let _month_ be _date_.[[Month]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _date_.[[Day]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), and _day_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id=sec-properties-of-temporal-date-instances>
    <h1>Properties of Temporal.Date Instances</h1>
    <p>Temporal.Date instances are ordinary objects that inherit properties from the %Temporal.Date.prototype%.</p>
    <p>Temporal.Date instances have the following internal slots:
    <ul>
      <li>[[Year]], representing the year.</li>
      <li>[[Month]], representing the month within the year. It lies between 1 and 12, inclusive.</li>
      <li>[[Day]], representing the day within the month. It lies between 1 and DaysInMonth([[Year]], [[Month]]), inclusive.</li>
    </ul>
    <p>The value of each of these internal slots is a Number which is an integer.</p>
  </emu-clause>

  <emu-clause id=sec-temporal-date-abstract-ops>
    <h1>Abstract operations</h1>

    <emu-clause id=sec-temporal-date-create aoid=CreateDate>
      <h1>CreateDate ( _y_, _m_, _d_ [, _newTarget_] )</h1>
      <emu-alg>
        1. Assert: ! ValidateDate(_y_, _m_, _d_) is *true*.
        1. If _newTarget_ is not given, set it to %Temporal.Date%
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.Date.prototype%"`, « [[InitializedTemporalDate]], [[Year]], [[Month]], [[Day]] »).
        1. Set _object_.[[Year]] to _y_.
        1. Set _object_.[[Month]] to _m_.
        1. Set _object_.[[Day]] to _d_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
