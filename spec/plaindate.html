<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindate-objects">
  <h1>Temporal.PlainDate Objects</h1>
  <p>A Temporal.PlainDate object is an immutable Object that contains integers corresponding to a
    particular year, month, and day in the ISO8601 calendar, as well as an Object value used to
    interpret those integers in a particular calendar.</p>

  <emu-clause id="sec-temporal-plaindate-constructor">
    <h1>The Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainDate%</dfn>.</li>
      <li>creates and initializes a new Temporal.PlainDate object when called as a constructor.</li>
      <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Temporal.PlainDate behaviour must include a super call to the %Temporal.PlainDate% constructor to create and initialize subclass instances with the necessary internal slots.</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate">
      <h1>Temporal.PlainDate ( _isoYear_, _isoMonth_, _isoDay_ [ , _calendarLike_ ] )</h1>
      <p>
        When the `Temporal.PlainDate` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _y_ be ? ToInteger(_isoYear_).
        1. Let _m_ be ? ToInteger(_isoMonth_).
        1. Let _d_ be ? ToInteger(_isoDay_).
        1. If _calendarLike_ is *undefined*, then
          1. Set _calendar_ to ? GetISO8601Calendar().
        1. Else,
          1. Set _calendar_ to ? ToTemporalCalendar(_calendarLike_).
        1. Return ? CreateTemporalDate(_y_, _m_, _d_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-constructor">
    <h1>Properties of the Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal-plaindate-prototype">
      <h1>Temporal.PlainDate.prototype</h1>
      <p>The initial value of `Temporal.PlainDate.prototype` is %Temporal.PlainDate.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate-@@species">
      <h1>get Temporal.PlainDate [ @@species ]</h1>
      <p>
        `Temporal.PlainDate[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.from">
      <h1>Temporal.PlainDate.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDate]] internal slot, then
          1. Return ? CreateTemporalDateFromStatic(_constructor_, _item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDate(_item_, _constructor_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.compare">
      <h1>Temporal.PlainDate.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Return ùîΩ(? CompareTemporalDateCalendar(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _one_.[[Calendar]],
            _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _two_.[[Calendar]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-prototype-object">
    <h1>Properties of the Temporal.PlainDate Prototype Object</h1>

    <p>The Temporal.PlainDate prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainDate.prototype%</dfn>.
      <li>is itself an ordinary object.
      <li>is not a Temporal.PlainDate instance and does not have a [[InitializedTemporalDate]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.plaindate.prototype.constructor">
      <h1>Temporal.PlainDate.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDate.prototype.constructor` is %Temporal.PlainDate%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype-@@tostringtag">
      <h1>Temporal.PlainDate.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.PlainDate"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.calendar">
      <h1>get Temporal.PlainDate.prototype.calendar</h1>
      <p>
        `Temporal.PlainDate.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return _temporalDate_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.year">
      <h1>get Temporal.PlainDate.prototype.year</h1>
      <p>
        `Temporal.PlainDate.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"year"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.month">
      <h1>get Temporal.PlainDate.prototype.month</h1>
      <p>
        `Temporal.PlainDate.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"month"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.day">
      <h1>get Temporal.PlainDate.prototype.day</h1>
      <p>
        `Temporal.PlainDate.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"day"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofweek">
      <h1>get Temporal.PlainDate.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofyear">
      <h1>get Temporal.PlainDate.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.weekofyear">
      <h1>get Temporal.PlainDate.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"weekOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinweek">
      <h1>get Temporal.PlainDate.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinmonth">
      <h1>get Temporal.PlainDate.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInMonth"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinyear">
      <h1>get Temporal.PlainDate.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthsinyear">
      <h1>get Temporal.PlainDate.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"monthsInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.inleapyear">
      <h1>get Temporal.PlainDate.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDate.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"inLeapYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainyearmonth">
      <h1>Temporal.PlainDate.prototype.toPlainYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"month"*, *"year"* ¬ª).
        1. Let _fields_ be ? ToTemporalYearMonthFields(_temporalDate_, _fieldNames_).
        1. Return ? YearMonthFromFields(_calendar_, _fields_, %Temporal.YearMonth%).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainmonthday">
      <h1>Temporal.PlainDate.prototype.toPlainMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"* ¬ª).
        1. Let _fields_ be ? ToTemporalMonthDayFields(_temporalDate_, _fieldNames_).
        1. Return ? MonthDayFromFields(_calendar_, _fields_, %Temporal.MonthDay%).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.getfields">
      <h1>Temporal.PlainDate.prototype.getFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"year"* ¬ª).
        1. Let _fields_ be ? ToTemporalDateFields(_temporalDate_, _fieldNames_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _calendar_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.getisofields">
      <h1>Temporal.PlainDate.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _temporalDate_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_temporalDate_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_temporalDate_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_temporalDate_.[[ISOYear]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.add">
      <h1>Temporal.PlainDate.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"days"*).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? AddDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Assert: ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.subtract">
      <h1>Temporal.PlainDate.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"days"*).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? SubtractDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Assert: ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.with">
      <h1>Temporal.PlainDate.prototype.with ( _temporalDateLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_temporalDateLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _calendarProperty_ be ? Get(_temporalDateLike_, *"calendar"*).
        1. If _calendarProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZoneProperty_ be ? Get(_temporalDateLike_, *"timeZone"*).
        1. If _timeZoneProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"year"* ¬ª).
        1. Let _partialDate_ be ? ToPartialDate(_temporalDateLike_, _fieldNames_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _fields_ be <mark>TODO</mark>.
        1. Let _constructor_ be ? SpeciesConstructor(_temporalDate_, %Temporal.PlainDate%).
        1. Return ? DateFromFields(_calendar_, _fields_, _constructor_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.withcalendar">
      <h1>Temporal.PlainDate.prototype.withCalendar ( _calendar_ )</h1>
      <p>
        The `withCalendar` method takes one argument _calendar_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be ? ToTemporalCalendar(_calendar_).
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.until">
      <h1>Temporal.PlainDate.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _calendarID_ be ? CalendarToString(_calendar_).
        1. Let _otherCalendar_ be _other_.[[Calendar]].
        1. Let _otherCalendarID_ be ? CalendarToString(_otherCalendar_).
        1. If _calendarID_ ‚â† _otherCalendarID_, throw a *RangeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hours"*, *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, *"nanoseconds"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, *"days"*, _disallowedUnits_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"days"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _result_ be ? CalendarDateUntil(_calendar_, _temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _largestUnit_).
        1. If _smallestUnit_ is not *"days"* or _roundingIncrement_ ‚â† 1, then
          1. Let _relativeTo_ be ! CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
          1. Set _result_ to ? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.since">
      <h1>Temporal.PlainDate.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _calendarID_ be ? CalendarToString(_calendar_).
        1. Let _otherCalendar_ be _other_.[[Calendar]].
        1. Let _otherCalendarID_ be ? CalendarToString(_otherCalendar_).
        1. If _calendarID_ ‚â† _otherCalendarID_, throw a *RangeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hours"*, *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, *"nanoseconds"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, *"days"*, _disallowedUnits_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"days"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _result_ be ? CalendarDateUntil(_calendar_, _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _largestUnit_).
        1. If _smallestUnit_ is *"days"* and _roundingIncrement_ = 1, then
          1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
        1. Let _relativeTo_ be ! CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Set _result_ to ? RoundDuration(‚àí_result_.[[Years]], ‚àí_result_.[[Months]], ‚àí_result_.[[Weeks]], ‚àí_result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Return ? CreateTemporalDuration(‚àí_result_.[[Years]], ‚àí_result_.[[Months]], ‚àí_result_.[[Weeks]], ‚àí_result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.equals">
      <h1>Temporal.PlainDate.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If _temporalDate_.[[ISOYear]] ‚â† _other_.[[ISOYear]], return *false*.
        1. If _temporalDate_.[[ISOMonth]] ‚â† _other_.[[ISOMonth]], return *false*.
        1. If _temporalDate_.[[ISODay]] ‚â† _other_.[[ISODay]], return *false*.
        1. Return ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplaindatetime">
      <h1>Temporal.PlainDate.prototype.toPlainDateTime ( [ _temporalTime_ ] )</h1>
      <p>
        The `toPlainDateTime` method takes one argument _temporalTime_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If _temporalTime_ is *undefined*, then
          1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]],
          _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]],
          _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]],
          _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tozoneddatetime">
      <h1>Temporal.PlainDate.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        The `toZonedDateTime` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_item_) is Object, then
          1. Let _timeZoneLike_ be ? Get(_item_, *"timeZone"*).
          1. If _timeZoneLike_ is *undefined*, then
            1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
            1. Let _temporalTime_ be *undefined*.
          1. Else,
            1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
            1. Let _temporalTime_ be ? Get(_item_, *"plainTime"*).
        1. Else,
          1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
          1. Let _temporalTime_ be *undefined*.
        1. If _temporalTime_ is *undefined*, then
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Else,
          1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _temporalDate_.[[Calendar]]).
        1. Let _instant_ be ? GetTemporalInstantFor(_timeZone_, _temporalDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tostring">
      <h1>Temporal.PlainDate.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Return ? TemporalDateToString(_temporalDate_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tolocalestring">
      <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return ? FormatDateTime(_dateFormat_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tojson">
      <h1>Temporal.PlainDate.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.valueof">
      <h1>Temporal.PlainDate.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindate-instances">
    <h1>Properties of Temporal.PlainDate Instances</h1>
    <p>
      Temporal.PlainDate instances are ordinary objects that inherit properties from the %Temporal.PlainDate.prototype% intrinsic object.
      Temporal.PlainDate instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldate-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldate-instances" caption="Internal Slots of Temporal.PlainDate Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDate]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainDate instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer between 1 and DaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindate-abstract-ops">
    <h1>Abstract Operations for Temporal.PlainDate Objects</h1>

    <emu-clause id="sec-temporal-createtemporaldate" aoid="CreateTemporalDate">
      <h1>CreateTemporalDate ( _isoYear_, _isoMonth_, _isoDay_, _calendar_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: _isoYear_ is an integer.
        1. Assert: _isoMonth_ is an integer.
        1. Assert: _isoDay_ is an integer.
        1. Perform ? RejectDate(_isoYear_, _isoMonth_, _isoDay_).
        1. If ! DateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, 12, 0, 0, 0, 0, 0) is not ~in range~, throw a *RangeError* exception.
        1. If Type(_calendar_) is not Object, throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.PlainDate%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDate.prototype%"*, ¬´ [[InitializedTemporalDate]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
      <emu-note>
        <p>Deferring to DateTimeWithinLimits with an hour of 12 avoids trouble at the extremes of the representable range of dates, which stop just before midnight on each end.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatefrominstance" aoid="CreateTemporalDateFromInstance">
      <h1>CreateTemporalDateFromInstance ( _temporalDate_, _isoYear_, _isoMonth_, _isoDay_, _calendar_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object and _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Assert: ! ValidateDate(_isoYear_, _isoMonth_, _isoDay_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_temporalDate_, %Temporal.PlainDate%).
        1. Let _result_ be ? Construct(_constructor_, ¬´ _isoYear_, _isoMonth_, _isoDay_, _calendar_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDate]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatefromstatic" aoid="CreateTemporalDateFromStatic">
      <h1>CreateTemporalDateFromStatic ( _constructor_, _isoYear_, _isoMonth_, _isoDay_, _calendar_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateDate(_isoYear_, _isoMonth_, _isoDay_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, ¬´ _isoYear_, _isoMonth_, _isoDay_, _calendar_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDate]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldate" aoid="ToTemporalDate">
      <h1>ToTemporalDate ( _item_ [ , _constructor_ [ , _overflow_ ] ] )</h1>
      <p>
        The abstract operation ToTemporalDate returns its argument _item_ if it is already a Temporal.PlainDate instance, converts _item_ to a new Temporal.PlainDate instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.PlainDate%.
        1. If _overflow_ is not given, set it to *"constrain"*.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Return _item_.
          1. Let _calendar_ be ? Get(_item_, *"calendar"*).
          1. If _calendar_ is *undefined*, set _calendar_ to ? GetISO8601Calendar().
          1. Set _calendar_ to ? ToTemporalCalendar(_calendar_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"year"* ¬ª).
          1. Let _fields_ be ? ToTemporalDateFields(_item_, _fieldNames_).
          1. Return ? DateFromFields(_calendar_, _fields_, _constructor_, _overflow_).
        1. Let _string_ be ? ToString(_item_).
        1. Let _result_ be ? ParseTemporalDateString(_string_).
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is *undefined*, set _calendar_ to ? GetISO8601Calendar().
        1. Set _calendar_ to ? ToTemporalCalendar(_calendar_).
        1. Set _result_ to ? RegulateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _overflow_).
        1. Return ? CreateTemporalDateFromStatic(_constructor_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencedate" aoid="DifferenceDate">
      <h1>DifferenceDate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_, _largestUnit_ )</h1>
      <emu-alg>
        1. Assert: _largestUnit_ is one of *"years"*, *"months"*, *"weeks"*, *"days"*, *"hours"*, *"minutes"*, or *"seconds"*.
        1. If _largestUnit_ is not *"years"*, *"months"*, or *"weeks"*, then
          1. Set _largestUnit_ to *"days"*.
        1. If _largestUnit_ is *"years"* or *"months"*, then
          1. Let _sign_ be -(! ES.CompareTemporalDate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_)).
          1. If _sign_ is 0, return the new Record { [[Years]]: 0, [[Months]]: 0, [[Weeks]]: 0, [[Days]]: 0 }.
          1. Let _start_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
          1. Let _end_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
          1. Let _years_ be _end_.[[Year]] ‚àí _start_.[[Year]].
          1. Let _mid_ be ? AddDate(_y1_, _m1_, _d1_, _years_, 0, 0, *"constrain"*).
          1. Let _midSign_ be -(! ES.CompareTemporalDate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"years"*, return the new Record { [[Years]]: _years_, [[Months]]: 0, [[Weeks]]: 0, [[Days]]: 0 }.
            1. Else, return the new Record { [[Years]]: 0, [[Months]]: _years_ √ó 12, [[Weeks]]: 0, [[Days]]: 0 }.
          1. Let _months_ be _end_.[[Month]] ‚àí _start_.[[Month]].
          1. If _midSign_ is not equal to _sign_, then
            1. Set _years_ to _years_ - _sign_.
            1. Set _months_ to _months_ + _sign_ √ó 12.
          1. Set _mid_ be ? AddDate(_y1_, _m1_, _d1_, _years_, _months_, 0, *"constrain"*).
          1. Let _midSign_ be -(! ES.CompareTemporalDate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"years"*, return the new Record { [[Years]]: _years_, [[Months]]: _months_, [[Weeks]]: 0, [[Days]]: 0 }.
            1. Else, return the new Record { [[Years]]: 0, [[Months]]: _months_ + _years_ √ó 12, [[Weeks]]: 0, [[Days]]: 0 }.
          1. If _midSign_ is not equal to _sign_, then
            1. Set _months_ to _months_ - _sign_.
            1. If _months_ is equal to -_sign_, then
              1. Set _years_ to _years_ - _sign_.
              1. Set _months_ to 11 √ó _sign_.
            1. Set _mid_ be ? AddDate(_y1_, _m1_, _d1_, _years_, _months_, 0, *"constrain"*).
            1. Let _midSign_ be -(! ES.CompareTemporalDate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. Let _days_ be 0.
          1. If _mid_.[[Month]] is equal to _end_.[[Month]] and _mid_.[[Year]] is equal to _mid_.[[Year]], set _days_ to _end_.[[Day]] - _mid_.[[Day]].
          1. Else if _sign_ &lt; 0, set _days_ to -_mid_.[[Day]] - (! DaysInMonth(_end_.[[Year]], _end_.[[Month]]) - _end_.[[Day]]).
          1. Else, set _days_ to _end_.[[Day]] + (! DaysInMonth(_mid_.[[Year]], _mid_.[[Month]]) - _mid_.[[Day]]).
          1. If _largestUnit_ is *"months"*, then
            1. Set _months_ to _months_ + _years_ √ó 12.
            1. Set _years_ to 0.
          1. Return the new Record { [[Years]]: _years_, [[Months]]: _months_, [[Weeks]]: 0, [[Days]]: _days_ }.
        1. If _largestUnit_ is *"days"* or *"weeks"*, then
          1. If ! CompareTemporalDate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_) &lt; 0, then
            1. Let _smaller_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
            1. Let _greater_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
            1. Let _sign_ be 1.
          1. Else,
            1. Let _smaller_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
            1. Let _greater_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
            1. Let _sign_ be ‚àí1.
          1. Let _years_ be _greater_.[[Year]] ‚àí _smaller_.[[Year]].
          1. Let _days_ be ! ToDayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) ‚àí ! ToDayOfYear(_smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
          1. Assert: _years_ ‚â• 0.
          1. Repeat, while _years_ &gt; 0,
            1. Set _days_ to _days_ + ! DaysInYear(_smaller_.[[Year]] + _years_ ‚àí 1).
            1. Set _years_ to _years_ ‚àí 1.
          1. Let _weeks_ be 0.
          1. If _largestUnit_ is *"weeks"*, then
            1. Set _weeks_ to floor(_days_ / 7).
            1. Set _days_ to _days_ mod 7.
          1. Return the Record {
            [[Years]]: 0,
            [[Months]]: 0,
            [[Weeks]]: _weeks_ √ó _sign_,
            [[Days]]: _days_ √ó _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatefields" aoid="ToTemporalDateFields">
      <h1>ToTemporalDateFields ( _temporalDateLike_, _fieldNames_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDateLike_) is Object.
        1. Let _result_ be ? OrdinaryObjectCreate(%Object.prototype%).
        1. For each value _property_ of _fieldNames_, do
          1. Let _value_ be ? Get(_temporalDateLike_, _property_).
          1. If _property_ is one of *"day"*, *"month"*, or *"year"*, then
            1. If _value_ is *undefined*, throw a *TypeError* exception.
            1. Set _value_ to ? ToInteger(_value_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialdate" aoid="ToPartialDate">
      <h1>ToPartialDate ( _temporalDateLike_, _fieldNames_ )</h1>
      <emu-alg>
        1. If Type(_temporalDateLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? OrdinaryObjectCreate(%Object.prototype%).
        1. Let _any_ be *false*.
        1. For each value _property_ of _fieldNames_, do
          1. Let _value_ be ? Get(_temporalDateLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. If _property_ is one of *"day"*, *"month"*, or *"year"*, then
              1. Set _value_ to ? ToInteger(_value_).
            1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatedate" aoid="RegulateDate">
      <h1>RegulateDate ( _year_, _month_, _day_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If _overflow_ is *"reject"*, then
          1. Perform ? RejectDate(_year_, _month_, _day_).
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_
            }.
        1. If _overflow_ is *"constrain"*, then
          1. Return ! ConstrainDate(_year_, _month_, _day_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatedate" aoid="ValidateDate">
      <h1>ValidateDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _daysInMonth_ be ! DaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _daysInMonth_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-rejectdate" aoid="RejectDate">
      <h1>RejectDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. If ! ValidateDate(_year_, _month_, _day_) is *false*, then
          1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraindate" aoid="ConstrainDate">
      <h1>ConstrainDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. Set _month_ to ! ConstrainToRange(_month_, 1, 12).
        1. Set _day_ to ! ConstrainToRange(_day_, 1, ! DaysInMonth(_year_, _month_)).
        1. Return the Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancedate" aoid="BalanceDate">
      <h1>BalanceDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. If _day_ is *+‚àû* or *‚àí‚àû*, then
          1. Throw a *RangeError* exception.
        1. Let _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_).
        1. Let _month_ be _balancedYearMonth_.[[Month]].
        1. Let _year_ be _balancedYearMonth_.[[Year]].
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in a year, the following section subtracts years and adds days until the number of days is greater than ‚àí366 or ‚àí365.
        1. Let _daysInYear_ be 0.
        1. If _month_ &gt; 2, then
          1. Let _testYear_ be _year_.
        1. Else,
          1. Let _testYear_ be _year_ ‚àí 1.
        1. Repeat, while _day_ &lt; ‚àí1 √ó ! DaysInYear(_testYear_),
          1. Set _day_ to _day_ + ! DaysInYear(_testYear_).
          1. Set _year_ to _year_ ‚àí 1.
          1. Set _testYear_ to _testYear_ ‚àí 1.
        1. NOTE: To deal with numbers of days greater than the number of days in a year, the following section adds years and subtracts days until the number of days is less than 366 or 365.
        1. Let _testYear_ be _year_ + 1.
        1. Repeat, while _day_ &gt; ! DaysInYear(_testYear_),
          1. Set _day_ to _day_ ‚àí ! DaysInYear(_testYear_).
          1. Set _year_ to _year_ + 1.
          1. Set _testYear_ to _testYear_ + 1.
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in the current month, the following section subtracts months and adds days until the number of days is greater than 0.
        1. Repeat, while _day_ &lt; 1,
          1. Set _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_ ‚àí 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
          1. Set _day_ to _day_ + ! DaysInMonth(_year_, _month_).
        1. NOTE: To deal with numbers of days greater than the number of days in the current month, the following section adds months and subtracts days until the number of days is less than the number of days in the month.
        1. Repeat, while _day_ &gt; ! DaysInMonth(_year_, _month_),
          1. Set _day_ to _day_ ‚àí ! DaysInMonth(_year_, _month_).
          1. Set _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_ + 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
        1. Return the new Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-padyear" aoid="PadYear">
      <h1>PadYear ( _y_ )</h1>
      <emu-alg>
        1. Assert: _y_ is an integer.
        1. If _y_ &gt; 999 and _y_ ‚â§ 9999, then
          1. Return _y_ formatted as a four-digit decimal number.
        1. If _y_ ‚â• 0, let _yearSign_ be *"+"*; otherwise, let _yearSign_ be *"-"*.
        1. Let _year_ be abs(_y_), formatted as a six-digit decimal number, padded to the left with zeroes as necessary.
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetostring" aoid="TemporalDateToString">
      <h1>TemporalDateToString ( _temporalDate_, _showCalendar_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object.
        1. Assert: _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Let _year_ be ! PadYear(_temporalDate_.[[ISOYear]]).
        1. Let _month_ be _temporalDate_.[[ISOMonth]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _temporalDate_.[[ISODay]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _calendarID_ be ? CalendarToString(_temporalDate_.[[Calendar]]).
        1. Let _calendar_ be ? FormatCalendarAnnotation(_calendarID_, _showCalendar_).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, and _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddate" aoid="AddDate">
      <h1>AddDate ( _year_, _month_, _day_, _years_, _months_, _weeks_, _days_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, _weeks_, and _days_ are integer Number values.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _y_ be _year_ + _years_.
        1. Let _m_ be _month_ + _months_.
        1. Let _intermediate_ be ? BalanceYearMonth(_y_, _m_).
        1. Let _intermediate_ be ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _day_, _overflow_).
        1. Set _days_ to _days_ + 7 √ó _weeks_.
        1. Let _d_ be _intermediate_.[[Day]] + _days_.
        1. Let _intermediate_ be ? BalanceDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
        1. Return ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldate" aoid="CompareTemporalDate">
      <h1>CompareTemporalDate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_ )</h1>
      <emu-alg>
        1. If _y1_ &gt; _y2_, return 1.
        1. If _y1_ &lt; _y2_, return -1.
        1. If _m1_ &gt; _m2_, return 1.
        1. If _m1_ &lt; _m2_, return -1.
        1. If _d1_ &gt; _d2_, return 1.
        1. If _d1_ &lt; _d2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldatecalendar" aoid="CompareTemporalDateCalendar">
      <h1>CompareTemporalDateCalendar ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_, _c1_, _c2_ )</h1>
      <emu-alg>
        1. Let _result_ be ! CompareTemporalDate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_).
        1. If _result_ ‚â† 0, then
          1. Return _result_.
        1. Return ? CompareCalendar(_c1_, _c2_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
