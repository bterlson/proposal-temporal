<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Temporal proposal
stage: 0
contributors: Maggie Pint, Matt Johnson, Brian Terlson, Daniel Ehrenberg, Philipp Dunkel, Sasha Pierson
</pre>
<emu-intro id=sec-intro>
    <h1>GregorianDate Objects</h1>
    <p>A GregorianDate object is an immutable Object that contains Number values corresponding to a particular year, month, and day.</p>
    <p>The following functions are abstract operations that operate on time values (defined SOMEWHERE).  Note that, in every case, if any argument to one of these functions is NaN, the result will be NaN.</p>
</emu-intro>
<emu-clause id=sec-year-number>
    <h1>Year Number</h1>
        <p>The Year Number is an integer Number corresponding to a particular year.  It is called the year value.  It must have a Number value and may not be NaN.
        </p>
</emu-clause>
<emu-clause id=sec-month-number>
    <h1>Month Number</h1>
    <p>
        The Month Number is a positive integer Number corresponding to a particular month.  It is called the month value and is identified by an integer in the range of 1 to 12, inclusive.  It must have a Number value and may not be NaN.
    </p>
</emu-clause>
<emu-clause id=sec-day-number>
    <h1>Day Number</h1>
    <p>
        The Day Number is a positive integer Number corresponding to a particular day of the month.  It is called the day value and is identified by an integer the value of which is dependent on the month and year values.  It must have a Number value and may not be NaN.  The range of possible day values can be calculated as follows:
    </p>
    <emu-alg>
            1. For any year value with a month values of 1, 3, 5, 7, 8, 10, or 12, the day value is in the range of 1 to 31, inclusive.

            1. For any year value with a month value of 4, 6, 9, or 11, the day value is in the range of 1 to 30, inclusive.

            1. For the month value 2, the range of possible values for the day value depends on whether the year value corresponds to a leap year.

                1. If the year value modulo 4 != 0, the range is 1 to 28, inclusive.

                1. If the year value modulo 400 == 0, the range is 1 to 29, inclusive.

                1. If the year value modulo 100 == and year value % 400 != 0, the range is 1 to 28, inclusive.

                1. If the year value modulo 4 == 0 and year value % 100 != 0, the range is 1 to 29, inclusive.
    </emu-alg>
</emu-clause>
<emu-clause id=sec-plus-operation>
    <h1>Plus(Object)</h1>
    <p>
        The abstract operation Plus returns a new GregorianDate object that may have 0 to 2 values copied from the GregorianDate object on which the operation was performed.  The new GregorianDate object will have one or more updated values that depend on terminal values of an Object passed in as the argument.  The argument Object consists of a range of 1 to 3 (inclusive) key-value pairs.  Each pair consists of a nonterminal symbol and a corresponding terminal Number.  An argument Object may have one and only one of each of the nonterminal symbols “Year”, “Month”, and “Day”.
    </p>
</emu-clause>
<emu-clause id=sec-with-operation>
  <h1>With(?_year, ?_month, ?_day)</h1>
  <p>The abstract operation With takes one Object argument and returns a new GregorianDate object.  The Object argument must have a range of 1 to 3 inclusive key/value pairs with the keys "year", "month", and/or "day".  The corresponding value for each key must be a Number.</p>
  <p>The new GregorianDate object copies the YearValue, MonthValue, and/or DayValue properties from the original GregorianDate object and replaces the property value(s) with the corresponding argument value.</p>
</emu-clause>
<emu-clause id=sec-withtime-operation>
    <h1>WithTime(time)</h1>
    <p>The abstract operation WithTime returns a GregorianDateTime object that copies and may update the year, month, and day values of the GregorianDate object on which the operation was performed.</p>
</emu-clause>
<emu-clause id=sec-constructor>
    <h1>GregorianDate Constructor</h1>
    <p>The GregorianDate constructor is the %GregorianDate% intrinsic object.  When called as a constructor, it creates and initializes a new GregorianDate object.</p>
    <p>The GregorianDate constructor is a single function.</p>
    <p>The GregorianDate constructor is subclassable</p>
    <p>The length property of the GregorianDate constructor function is 3.</p>
    <emu-grammar>
    </emu-grammar>
</emu-clause>
<emu-clause id=sec-constructor-alg>
    <h1>GregorianDate (year, month, day)</h1>
    <p>This description only applies if the GregorianDate constructor is called with at least 3 arguments.</p>
    <p>When the GregorianDate function is called, the following steps are taken:</p>
    <emu-alg>
        1.	Let numberOfArgs be the number of arguments passed to this function call.

        2.	Assert: numberOfArgs == 3.

        3.	If NewTarget is not undefined, then

            a.	Let y be ? ToNumber(year)

            b.	Let m be ? ToNumber(month)

            c.	Let d be ? ToNumber(Day)
    </emu-alg>
</emu-clause>
<emu-clause id=sec-constructor-prop>
    <h1>Properties of the GregorianDate Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the GregorianDate constructor is the intrinsic object %FunctionPrototype%.</p>
    <p>The GregorianDate constructor has the following properties:</p>
</emu-clause>
<emu-clause id=sec-prototype>
    <h1>GregorianDate Prototype</h1>
    <p>The initial value of GregorianDate.prototype is the intrinsic object %GregorianDatePrototype%.  This property has the attributes {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}.</p>
</emu-clause>
<emu-clause id=sec-plus-alg>
    <h1>GregorianDate.plus (data)</h1>
    <p>The abstract operation plus takes as an argument an Object with a range of 1 to 3 key/value pairs, inclusive.</p>
    <p>The keys may not be duplicated and may be any combination of “year”, “month”, “day”.</p>
    <p>The values must be of the Number type and may be positive or negative integers.</p>
    <p>If the sum of the current value and the argument value exceeds the range of allowable values for the given unit, increment the next unit.</p>
    <p>The GregorianDate operation uses Gregorian pro-leptic calendar computation.</p>
    <p>When the plus function is called, the following steps are taken:</p>
    <emu-alg>
        1.	Let numberOfArgs be the number of arguments passed to this function call.
        2. Assert: Type(data) is Object.
        2.	Assert: numberOfArgs == 1.
        3.	If NewTarget is not undefined, then
          a. If data.year is supplied, let y be ? ToNumber(year) + thisYearValue. If y is NaN, throw a TypeError exception; else if data.year is not supplied, let y be thisYearValue.
          b. If data.month is supplied, let m be ? ToNumber(month) + thisMonthValue. If m is NaN, throw a TypeError exception; else if data.month is not supplied, let m be thisMonthValue.
          c. If data.day is supplied, let d be ? ToNumber(day) + thisDayValue. If d is NaN, throw a TypeError exception; else if data.day is not supplied, let d be thisDayValue.
          d. Regulate the final y, m, and d values using Gregorian pro-leptic calendar calculations.
          e.  Let O be ? OrdinaryCreateFromConstructor(New Target, "%GregorianDatePrototype%", y, m, d)
          f. Set O.[[YearValue]] to y.
          g. Set O.[[MonthValue]] to m.
          h. Set O.[[DayValue]] to d.
          i. Return O.
        4. Else, TBD
    </emu-alg>
</emu-clause>
<emu-clause id=sec-with-alg>
  <h1>GregorianDate.with (data)</h1>
    <p>The abstract operation plus takes as an argument an Object with a range of 1 to 3 key/value pairs, inclusive.</p>
    <p>The keys may not be duplicated and may be any combination of “year”, “month”, “day”.</p>
    <p>The values must be of the Number type and may be positive or negative integers.</p>
    <p>The GregorianDate operation uses Gregorian pro-leptic calendar computation.</p>
    <p>When the with function is called, the following steps are taken:</p>
  <emu-alg>
    1. Let numberOfArgs be the number of arguments passed to this function call.
    2. Assert: numberOfArgs == 1.
    3. Assert: Type(data) is Object.
    3. If NewTarget is not undefined, then
      a. If data.year is supplied, let y be ? ToNumber(year). If y is NaN, throw a TypeError exception; else if data.year is not supplied, let y be thisYearValue.
      b. If data.month is supplied, let m be ? ToNumber(month). If m is NaN, throw a TypeError exception; else if data.month is not supplied, let m be thisMonthValue.
      c. If data.day is supplied, let d be ? ToNumber(day). If d is NaN, throw a TypeError exception; else if data.day is not supplied, let d be thisDayValue.
      d. Regulate the final y, m, and d values using Gregorian pro-leptic calendar calculations.
      e. Let O be ? OrdinaryCreateFromConstructor(New Target, "%GregorianDatePrototype%", y, m, d)
      f. Set O.[[YearValue]] to y.
      g. Set O.[[MonthValue]] to m.
      h. Set O.[[DayValue]] to d.
      i. Return O.
    4. Else, TBD
  </emu-alg>
</emu-clause>
<emu-clause id=sec-fromstring-alg>
  <h1>GregorianDate.fromString (string)</h1>
  <emu-alg>

  </emu-alg>
</emu-clause>
<emu-clause id=sec-fromzonedinstant-alg>
  <h1>GregorianDate.fromZonedInstant (zonedinstant)</h1>
  <emu-alg>

  </emu-alg>
</emu-clause>
